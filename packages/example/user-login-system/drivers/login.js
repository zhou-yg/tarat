import {
  state,
  cache,
  model,
  computed,
  combineLatest,
  inputCompute,
  inputComputeInServer,
  writePrisma,
} from "tarat-core";
import { nanoid } from "nanoid";

export default function login() {
  const password = state();

  const name = state();

  const inputName = state();
  const inputPassword = state();
  const repeatPassword = state();

  const userDataByInput = model("user", (prev) => {
    if (name() && password()) {
      return {
        where: {
          name: name(), // maybe be unique?
          password: password(),
        },
        select: {
          id: true,
          name: true,
        },
      };
    }
  });
  const writeUserData = writePrisma(userDataByInput, () => ({
    data: {
      name: name(),
      password: password(),
    },
  }));

  const signAndAutoLogin = state(false);

  const cookieId = cache("userDataKey", { from: "cookie" }); // just run in server because by it depends 'cookie'

  const sessionStore = model(
    "sessionStore",
    (prev) => {
      const cid = cookieId();
      // client: ps, server: no?
      if (cid) {
        return {
          where: {
            fromIndex: cid,
          },
        };
      }
    },
    { ignoreClientEnable: true }
  );
  const writeSessionStore = writePrisma(sessionStore);

  const userDataByCookie = model("user", (prev) => {
    const ss = sessionStore();
    if (ss & (ss.length > 0)) {
      return {
        where: {
          id: ss[0].userId,
        },
      };
    }
  });
  /* 11 */
  const userData = computed(() => {
    const u1 = userDataByCookie();
    if (u1?.length > 0) {
      return u1[0];
    }
    const u2 = userDataByInput();
    if (u2?.length > 0) {
      return u2[0];
    }
  });

  /* 12 */
  const alreadyLogin = computed(() => {
    const ud = userData();
    return !!ud;
  });

  /**
   * login:
   * 1.invalid password
   * 2.check repeat password (should handled by UI)
   * 3.user not exist
   *
   * sign:
   * 1.user already exist
   *
   * common:
   * 1.http error
   */
  const errorTip1 = computed(async () => {
    if (name() && password() && !userData()) {
      return "invalid password";
    }
    if (repeatPassword() && repeatPassword() !== password()) {
      return "input same password twice";
    }
    if (name() === "") {
      return "must input name";
    }
    if (password() === "") {
      return "must input password";
    }
    return "";
  });

  const errorTip2 = state("");

  const errorTip = combineLatest([errorTip1, errorTip2]);

  const sign = inputComputeInServer(function* () {
    const inputNameVal = inputName();
    const inputPasswordVal = inputPassword();
    const r = yield userDataByInput.exist({
      name: inputNameVal,
      password: inputPasswordVal,
    });
    if (!r) {
      yield writeUserData.create();

      if (signAndAutoLogin()) {
        yield login(inputNameVal, inputPasswordVal);
      }
    } else {
      errorTip2(() => "user already exist");
    }
  });

  /* 16 */
  const login = inputComputeInServer(function* () {
    const inputNameVal = inputName();
    const inputPasswordVal = inputPassword();
    const existUser = yield userDataByInput.exist({
      name: inputNameVal,
      password: inputPasswordVal,
    }); // query DB
    if (existUser) {
      name(() => inputNameVal);
      password(() => inputPasswordVal);

      const nid = nanoid();

      yield writeSessionStore.create({
        userId: existUser.id,
        fromIndex: nid,
      });

      cookieId(() => nid);
    } else {
      errorTip2(() => `invalid password with "${inputNameVal}"`);
    }
  });

  const logout = inputComputeInServer(function* () {
    const cid = cookieId();
    cookieId(() => "");

    name(() => null);
    password(() => null);

    const ss = sessionStore().find((o) => o.fromIndex === cid);
    if (ss) {
      yield writeSessionStore.remove(ss.id);
    }
  });

  return {
    alreadyLogin,
    name,
    password,
    inputName,
    inputPassword,
    repeatPassword,
    signAndAutoLogin,
    userData,
    errorTip,
    sign,
    login,
    logout,
  };
}

/**. auto generated by tarat */
const autoParser = {
  login: {
    names: [
      [0, "password"],
      [1, "name"],
      [2, "inputName"],
      [3, "inputPassword"],
      [4, "repeatPassword"],
      [5, "userDataByInput"],
      [6, "writeUserData"],
      [7, "signAndAutoLogin"],
      [8, "cookieId"],
      [9, "sessionStore"],
      [10, "writeSessionStore"],
      [11, "userDataByCookie"],
      [12, "userData"],
      [13, "alreadyLogin"],
      [14, "errorTip1"],
      [15, "errorTip2"],
      [16, "sign"],
      [17, "login2"],
      [18, "logout"],
    ],
    deps: [
      ["h", 5, [1, 0]],
      ["h", 6, [5, 1, 0], [5, 1, 0]],
      ["h", 9, [8]],
      ["h", 10, [9], [9]],
      ["h", 11, [9]],
      ["h", 12, [11, 5]],
      ["h", 13, [12]],
      ["h", 14, [1, 0, 12, 4]],
      ["h", 16, [2, 3, 6, 7], [5, 17, 15]],
      ["h", 17, [2, 3], [5, 1, 0, 10, 8, 15]],
      ["h", 18, [8, 9], [8, 1, 0, 10]],
    ],
  },
};
Object.assign(login, {
  __deps__: autoParser.login.deps,
  __names__: autoParser.login.names,
  __name__: "login",
});
/** auto generated by tarat .*/
