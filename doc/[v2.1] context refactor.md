# context refactor

- Runner
  - only receive a BM as initial parameter
  - call init method with
    - BM's arguments
    - Context from another side

- CurrentRunnerScope
  - add new property "context"
  - add new property "currentInputCompute" maybe null
  - migrate directly hook operating to Context
    - addHook
    - proxy applyContext method from Context
  - subscribe onUpdate event from Context
  - commitPatches
    - arguments:
      - fromHook
      - final value
      - patches
    - detect if under InputCompute
      - yes:
        - commit to draftContext (might with patches) by using Context api
      - no:
        - update original context directly

- Context (a new added Class)
  - 3 basic properties
    - hooks: hook object by Hook
    - values: hook's memoized data, map value to hooks by index
    - depMaps: hook's dependence relation collection
    - inputComputeAndDraft: inputCompute , draftValues, draftPatches 3 tuple
      - comments: draftContext is shallow copy from original Context preventing Proxy Object.freeze error
  - applyContext
    - arguments: 
      - values: received memoized data array from another side
      - depMaps: dep relation array from another side, keep same data structure
    - set received contextData to self's values/depMaps
  - commitDraft
    
  - getValue/setValue, handle dependence relation same time
    - value operate description
      - client:
        - getValue
          - Model: post query rpc
          - Cache: 
            server: post query rpc
            client: get value from client cache
          - Computed/State: read memory
        - setValue:
          - Model: throw error because of client can't set value to model directly
          - Cache:
            - server: post query rpc
            - client: set value to client cache
          - Computed/State: set memory
      - server:
        - getValue
          - Model: execute DB query
          - Cache
            - server: get from server cache like redis
            - client: throw error
          - Computed/State: read memory
        - setValue
          - Model: execute DB writing
          - Cache
            - server: update server cache
            - client: throw error
          - Computed/State: update memory
    - handle dependence
      - detect if CurrentInputComptue or CurrentComputed
        - CurrentInputComptue:
          - yes:
          - no:
        - CurrentComputed:
          - yes:
          - no:
  - addHook
  - addHookAndValue

- hookFactory: mountHookFactory / updateHookFactory
  - detect if with context
    - yes: set updateHookFactory to current global flag
    - no: set mountHookFactory to current global flag
  - value getter replace "hook.value" with reading value from Scope
    - reading path: getter function -> get value from context with current hook () -> current value

- mountHookFactory
  - mountState
    - set initial arg to context.values
  - mountModel
    - check if immediate
      - yes: get from context and post query
      - no: set blank array
  - mountComputed
    - execute getter
  - inputCompute
  - inputComputeInServer
  - after
  - before
  - cache
  - combineLatest

- updateHookFactory
  - updateState
    - ignore intial arg
  - updateModel
    - server: ignore values and check if immediate
    - client: do nothing even if immediate
  - updateComputed
    - have no need of executing getter
  - inputCompute
  - inputComputeInServer
  - after
  - before
  - cache
  - combineLatest