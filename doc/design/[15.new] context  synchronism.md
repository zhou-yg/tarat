# Context状态同步

考虑client/server之间同步 context data and depMaps

## 依赖的编译时检测

在hook内是一个closure, 内部的state/model都是名称确定的

所以通过分析AST就直接建立depMaps，无需在hook运行之后才能确定

```javascript
function hook () {
  const myState = state()
  const ic = inputCompute(() => {
    myState(v => v + 1)
  })
  return { myState, ic }
}
```

通过扫AST，可以得知ic内是依赖了myState，而且这里不用担心引用问题

因为myState这个变量的作用域只在hook内，它的引用也是确定的，所以一定是hook内被使用，所以可以被AST扫描

结合hook的compose情况，由于hook的return的变量也一定是myState，在hook范围内

所以compose情况也可以扫AST得到

加入编译时之后，那在运行时就不用设置各种全局变量的flag了

但是没有flag的话会无法识别到myState里的具体字段的依赖，因为在getter里是会有动态逻辑，但这不影响大粒度的state依赖关系

```javascript
// must be PlainObject
const hookDepMaps = [
  {
    target: 0, // can find target hook by the unique index
    deps: [ 1 ]
  },
  {
    target: 2,
    deps: [ 3, 4 ]
  }
]
```

## Context data

there are some top questions：
- computed触发getter的时机，在client触发还是server触发
- send context时， 要携带的hook的值的范围怎么确定，依据是什么
- BM的初始化过程的流程该怎么抽象，初始化的数据源可以有哪些
- 确定hook的执行环境的默认原则，比如model在server端，如何通过尽可能少的配置化方式来修改它
- lazy model如何从server端同步数据
- 同步过程中如何避免触发hook中无关的model的重新get？


core principles list sort by priority:
- model的查询默认只能在server端执行
  - 推演：computed内如果使用了异步的model，可以在client，等待Model的server数据返回即可


忽略client/server的差别，focus on 2 new abstract concepts:
- sender
- receiver

sender part
  - send context
    - with callHook:
      - 语义：修改状态, post操作
    - without callHook: 
      - 语义：同步状态，get操作
        - 类似hook的初始化过程，初始的过程中可能有3个值来源： 默认值，当前context，或者远端
          - 参考结合lazy的特性，如qwik.js
  - 等待并接收最新的context
    - post操作 
      - state可能会变
      - 其它可能会变
    - get操作
      - state不会变
      - 其它可能会变
