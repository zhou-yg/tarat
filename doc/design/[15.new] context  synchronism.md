# Context状态同步

考虑client/server之间同步 context data and depMaps

## 依赖的编译时检测

在hook内是一个closure, 内部的state/model都是名称确定的

所以通过分析AST就直接建立depMaps，无需在hook运行之后才能确定

```javascript
function hook () {
  const myState = state()
  const ic = inputCompute(() => {
    myState(v => v + 1)
  })
  return { myState, ic }
}
```

通过扫AST，可以得知ic内是依赖了myState，而且这里不用担心引用问题

因为myState这个变量的作用域只在hook内，它的引用也是确定的，所以一定是hook内被使用，所以可以被AST扫描

结合hook的compose情况，由于hook的return的变量也一定是myState，在hook范围内

所以compose情况也可以扫AST得到

加入编译时之后，那在运行时就不用设置各种全局变量的flag了

但是没有flag的话会无法识别到myState里的具体字段的依赖，因为在getter里是会有动态逻辑，但这不影响大粒度的state依赖关系

```javascript
// must be PlainObject
const hookDepMaps = [
  {
    target: 0, // can find target hook by the unique index
    deps: [ 1 ]
  },
  {
    target: 2,
    deps: [ 3, 4 ]
  }
]
```

## Context data

忽略client/server的差别，专注于 sender and receiver

- sender
  - 发送context
    - with callHook: 修改状态, post操作
    - without callHook: 同步状态，get操作
      - 类似hook的初始化过程，从默认值，当前context，或者远端取值，
        - 参考结合lazy的特性，如qwik.js
  - 等待并接收最新的context
    - post操作 
      - state可能会变
      - 其它可能会变
    - get操作
      - state不会变
      - 其它可能会变
